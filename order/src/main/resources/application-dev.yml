server:
  port: 8392

spring:
  shardingsphere:
    mode:
      type: Standalone  # 可选：Standalone、Cluster
    props:
      sql-show: true # 日志打印SQL
      xa-transaction-manager-type: Atomikos
    datasource:  #定义数据源
      names: ds0,ds1,ds2 # 数据库名称列表
      ds0:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/order?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&serverTimezone=GMT%2B8&useSSL=false
        username: root
        password: root
      ds1:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/order_1?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&serverTimezone=GMT%2B8&useSSL=false
        username: root
        password: root
      ds2:
        type: com.alibaba.druid.pool.DruidDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/order_2?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true&serverTimezone=GMT%2B8&useSSL=false
        username: root
        password: root
    rules:
      sharding:
        tables: # 需要分库表的规则配置
          order_t:
            actual-data-nodes: ds0.order_t$->{1..4}  # 待选数据节点：ds0.order_t1、ds0.order_t2、ds0.order_t3
            key-generate-strategy:  # 分布式ID列，一般是主键
              column: order_id
              key-generator-name: beautySnowflake # 使用雪花算法
#            database-strategy: # 分库策略配置
#              standard: # 标准算法，可选：standard、complex、hint、none
#                sharding-column: user_id # 分片列
#                sharding-algorithm-name: order_inline # 分片算法
            table-strategy: # 分库策略配置
              standard: # 标准算法，可选：standard、complex、hint、none
                sharding-column: order_date # 分片列
                sharding-algorithm-name: quarter_std # 分片算法
        key-generators: # 分布式ID生成算法
          snowflake:
            type: SNOWFLAKE  # 内置雪花算法，参考：org.apache.shardingsphere.sharding.algorithm.keygen.SnowflakeKeyGenerateAlgorithm
            props:
              worker-id: 100
          beautySnowflake:
            type: BEAUTY_SNOWFLAKE
        sharding-algorithms: # 分片算法，配置后可以在分片表的分片策略中被引用
          default_database_inline: # 算法名称
            type: INLINE # 行内表达式算法
            props:
              algorithm-expression: ds$->{created_by % 3} # 将数据按created_by对3取余，均分到ds0、ds1、ds2
          order_inline:
            type: INLINE
            props:
              algorithm-expression: ds$->{user_id % 3} # 将数据按user_id对3取余，均分到ds0、ds1、ds2
          quarter_std:
            type: CLASS_BASED
            props:
              strategy: standard
              algorithmClassName: com.xlt.sharding.startegy.DateStdShardingAlgorithm
              lowerLimit: "2023-01-01 00:00:00"
              upperLimit: "2023-12-31 24:00:00"
              interval: 3
        default-database-strategy: # 默认分库算法
          standard:
            sharding-column: created_by
            sharding-algorithm-name: default_database_inline


  redis:
    host: 127.0.0.1
    port: 6379
    # password: xlt
    database: 0
    lettuce:
      pool:
        max-active: 8 # 连接池最大连接数 默认8 ，负数表示没有限制
        max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认-1
        max-idle: 8 # 连接池中的最大空闲连接 默认8
        min-idle: 0 # 连接池中的最小空闲连接 默认0
  # MQ配置
  rabbitmq:
    host: localhost
    port: 5672
    username: xlt
    password: xlt
    # 虚拟host 可以不设置,使用server默认host
    virtual-host: XltHost
    listener:
      simple:
        acknowledge-mode: manual #设置确认模式手工确认
        concurrency: 3 #消费者最小数量
        max-concurrency: 10 # 消费者最大数量
        retry:
          #开启消费者（程序出现异常的情况下会）进行重试
          enabled: true
          #最大重试次数
          max-attempts: 3
          #重试间隔次数
          initial-interval: 300
          #开启手动ack
          #acknowledge-mode: manual
